use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::groups::group_manager::GroupId;
use crate::identity::identity_key::IdentityId;

/// Enumeration of group event types. This list mirrors the events
/// generated by `GroupManager` such as group creation, member changes
/// and settings updates. Additional variants can be added as new
/// functionality is implemented.
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
pub enum GroupEventType {
    /// A new group was created.
    GroupCreated,
    /// A member was added to the group.
    MemberAdded,
    /// A member was removed from the group.
    MemberRemoved,
    /// A member voluntarily left the group.
    MemberLeft,
    /// A member's role was changed (e.g. promoted to admin).
    RoleChanged,
    /// An invitation was created by a group admin.
    InvitationCreated,
    /// The group settings were changed.
    SettingsChanged,
}

/// Records a single group event along with contextual metadata.
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct GroupEvent {
    /// The group this event pertains to.
    pub group_id: GroupId,
    /// The actor (identity) that triggered the event.
    pub actor_id: IdentityId,
    /// The specific type of event.
    pub event_type: GroupEventType,
    /// Human‑readable description of what occurred.
    pub description: String,
    /// Unix timestamp when the event occurred.
    pub timestamp: u64,
}

/// An append‑only log of group events. This structure holds events
/// purely in memory; persistence is handled by the `GroupManager`
/// via its keystore. Applications can maintain a `GroupEventLog` to
/// reconstruct historical group state for auditing or display.
#[derive(Default)]
pub struct GroupEventLog {
    events: Vec<GroupEvent>,
}

impl GroupEventLog {
    /// Create a new, empty event log.
    pub fn new() -> Self {
        GroupEventLog { events: Vec::new() }
    }
    /// Append an event to the log. In most cases events should be
    /// generated via `GroupManager::log_group_event` to ensure they are
    /// persisted.
    pub fn add_event(&mut self, event: GroupEvent) {
        self.events.push(event);
    }
    /// Return an immutable slice of all recorded events.
    pub fn events(&self) -> &[GroupEvent] {
        &self.events
    }
}

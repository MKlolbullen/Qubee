//! Signaling primitives for establishing WebRTC sessions over the
//! encrypted Qubee messaging channel. The signaling layer is
//! responsible for exchanging call invitations, SDP offers/answers
//! and ICE candidates between participants. It does not perform any
//! network I/O itself; instead it routes messages through an in‑memory
//! server so that unit tests and local peer connections can be
//! exercised without external dependencies.

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};

use crate::calling::call_manager::{CallId, CallSettings, CallType};
use crate::calling::peer_connection::ICECandidate;
use crate::identity::identity_key::IdentityId;

/// High‑level signaling message exchanged between peers. Each
/// variant carries the metadata necessary for the recipient to act
/// upon the message. Messages are addressed to a specific identity
/// and routed by the [`SignalingServer`].
#[derive(Clone, Serialize, Deserialize, Debug)]
pub enum SignalingMessage {
    /// Invitation to join a call. Sent from the initiator to each
    /// participant. The recipient can either accept the invitation,
    /// triggering a WebRTC negotiation, or reject it.
    CallInvitation {
        call_id: CallId,
        caller: IdentityId,
        call_type: CallType,
        settings: CallSettings,
    },
    /// An SDP offer generated by a peer. The recipient should set
    /// this as its remote description and respond with an answer.
    SdpOffer {
        call_id: CallId,
        sdp: String,
        sender: IdentityId,
    },
    /// An SDP answer generated in response to an offer. The sender
    /// that generated the offer should set this as its remote
    /// description.
    SdpAnswer {
        call_id: CallId,
        sdp: String,
        sender: IdentityId,
    },
    /// An ICE candidate discovered by the local peer. The recipient
    /// should add this candidate to its peer connection.
    IceCandidate {
        call_id: CallId,
        candidate: ICECandidate,
        sender: IdentityId,
    },
    /// Signal that a participant has hung up. The recipient should
    /// close its local peer connection and mark the call as ended.
    HangUp {
        call_id: CallId,
        sender: IdentityId,
    },
}

/// In‑memory signaling server that routes messages between
/// registered clients. Each client registers with a unique
/// `IdentityId` and receives messages via an unbounded channel.
/// Clients can also send messages via the server to other
/// identities. This avoids requiring an external signalling service
/// for tests and local operation.
pub struct SignalingServer {
    clients: Arc<RwLock<HashMap<IdentityId, mpsc::UnboundedSender<SignalingMessage>>>>,
}

impl SignalingServer {
    /// Create a new empty signaling server. This should be called
    /// once at application startup.
    pub async fn new() -> Result<Self> {
        Ok(SignalingServer {
            clients: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    /// Register a new client with the server. Returns a
    /// [`SignalingClient`] that can receive messages destined for
    /// `identity`. If another client is already registered with the
    /// same identity it will be replaced. Clients should call
    /// `register_client` before attempting to send or receive
    /// signaling messages.
    pub async fn register_client(
        &self,
        identity: IdentityId,
    ) -> SignalingClient {
        let (tx, rx) = mpsc::unbounded_channel();
        {
            let mut clients = self.clients.write().await;
            clients.insert(identity, tx);
        }
        SignalingClient {
            identity,
            server: Arc::new(self.clone()),
            receiver: rx,
        }
    }

    /// Send a signaling message to the specified recipient. If the
    /// recipient is not currently registered, an error is returned.
    pub async fn send_message(
        &self,
        recipient: IdentityId,
        message: SignalingMessage,
    ) -> Result<()> {
        let clients = self.clients.read().await;
        if let Some(tx) = clients.get(&recipient) {
            tx.send(message).map_err(|e| anyhow::anyhow!(e.to_string()))?
        } else {
            return Err(anyhow::anyhow!("No signaling client registered for recipient"));
        }
        Ok(())
    }
}

impl Clone for SignalingServer {
    fn clone(&self) -> Self {
        SignalingServer {
            clients: self.clients.clone(),
        }
    }
}

/// Client handle for receiving and sending signaling messages. Each
/// participant in a call holds a `SignalingClient` associated with
/// their `IdentityId`. The client can be used to await incoming
/// messages and to send messages via the server.
pub struct SignalingClient {
    identity: IdentityId,
    server: Arc<SignalingServer>,
    receiver: mpsc::UnboundedReceiver<SignalingMessage>,
}

impl SignalingClient {
    /// Receive the next signaling message destined for this client.
    /// Returns `None` if the channel has been closed.
    pub async fn recv(&mut self) -> Option<SignalingMessage> {
        self.receiver.recv().await
    }

    /// Send a signaling message to another participant via the
    /// associated server. This is simply a convenience wrapper around
    /// [`SignalingServer::send_message`].
    pub async fn send_to(
        &self,
        recipient: IdentityId,
        message: SignalingMessage,
    ) -> Result<()> {
        self.server.send_message(recipient, message).await
    }
}

/// Backwards compatibility for the previous `CallSignal` type. The
/// older implementation serialised signalling messages directly as
/// bincode blobs. We retain the ability to serialise and
/// deserialise messages for transport over the encrypted chat layer.
impl SignalingMessage {
    /// Serializes the signal to bytes for encryption.
    pub fn to_bytes(&self) -> Result<Vec<u8>, bincode::Error> {
        bincode::serialize(self)
    }

    /// Tries to parse bytes into a `SignalingMessage`.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, bincode::Error> {
        bincode::deserialize(bytes)
    }
}
